Mattia 4 Aug 2017
=================
Hi Valeriu,

thanks for your prompt reactions!


    - alternatively we can use a minimal amount of interface_ code (look at
    main_0_0.py) -- basically just getting the options for various
    parameters straight from the parser, build the preprocessor and then
    just fire up the diagnostic.


I would personally go for this approach. The current code is pretty complicated and it will become difficult to maintain as long as the tool evolves with more and more features.

Since we are facing a big change anyway when switching to the revised backend, I think it is the right time to also clean up some of the old interface and go for something more transparent and easy to maintain.


> One technical question here: setting

    environment variables from the Python main code to be passed straight to
    NCL or R diagnostics didnt work for me (to be honest I am very weary to
    use os.environ to start passing analysis variables, just because I think
    this should be parallelized at a point in the future and navigating from
    one environment to another with floating variables seems nightmare).


I remember we discussed this issue some time ago and the answer was that it is not possible. But Niels/Bj?rn shall correct me if I'm wrong.

    Anyways, - my idea was to allow main to write some temporary variable
    files, and this way the code worked fine for me.


This is ok, as long as a different tmp directory is created for each instance (allowing to run multiple instances of the tool at the same time). See also:

https://github.com/ESMValGroup/ESMValTool/issues/3

    I guess the question here is - how much of the interface_ codes do we
    want to keep? I mean, I guess a much lighter version can easily be
    built, but one has to be very careful they account for all the cases
    that are taken care of in the present version.


I think the new yaml format is flexible enough to cover all cases we have now. Axel and I discussed this quite a lot and we could not think of any specific case that cannot be covered in yaml. The only think yet to be defined is how to handle the fx files, but it should be easy to add them.


Bjorn 4 Aug 2017
================
Hi Valeriu,

your question:
>I have been looking all around the code to find where this (initially) dictionary gets converted to a Diagnostic object that can be operated on afterwards. Any ideas?

PyYaml offers some kind of magic that fills up instances of Python-objects according to a declaration in the yaml file itself (check  http://pyyaml.org/wiki/PyYAMLDocumentation#Constructorsrepresentersresolvers). We used it here
https://github.com/ESMValGroup/ESMValTool/blob/REFACTORING_backend/orchestrator/parser/evt.py
In YAML - there is something called a "tag" and it starts with a "!". If you mark your class with that and use the tag in the YAML file this gets "resolved" by the yaml-module.
